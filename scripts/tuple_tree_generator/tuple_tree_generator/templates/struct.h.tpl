#pragma once

/*#-
This template file is distributed under the MIT License. See LICENSE.md for details.
The notice below applies to the generated files.
#*/
//
// This file is distributed under the MIT License. See LICENSE.md for details.
//

// This file is autogenerated! Do not edit it directly

#include <compare>

#include "revng/TupleTree/TupleTreeReference.h"
#include "revng/Support/Assert.h"

/**- for header in struct.includes **/
#include "/*= generator.user_include_path =*//*= header =*/"
/**- endfor **/

/*= struct.doc | docstring -=*/
struct /*= struct.fullname =*/
  /**- if struct.inherits **/ : public /*= struct.inherits.user_fullname =*/ /** endif -**/
{
  /**- if struct.inherits **/
  static constexpr const /*= struct.inherits.name =*/Kind::Values AssociatedKind = /*= struct.inherits.name =*/Kind::/*= struct.name =*/;
  /**- endif **/

  /*#- --- Member list --- #*/
  /**- for field in struct.fields **/
  /*= field.doc | docstring =*/
  /**- if field.const **/const /** endif -**/
  /*= field.type =*/ /*= field.name =*/ = /*= field.type =*/{};
  /**- endfor **/

  /*# --- Default constructor --- #*/
  /// Default constructor
  /*= struct.name =*/() :
    /**- if struct.inherits **//*= struct.inherits.name =*/()/** endif **/
    /**- for field in struct.fields **/
    /**- if not loop.first or struct.inherits **/, /** endif **//*= field.name =*/()
    /**- endfor **/ {
      /**- if struct.inherits -**/
      Kind = AssociatedKind;
      /**- endif -**/
    }

  /*# --- Key constructor --- #*/
  /**- if struct.key_fields **/
  /// Key constructor
  /*= struct.name =*/(
    /**- for field in struct.key_fields **/
    /*=- field.type =*/ /*= field.name =*//** if not loop.last **/, /** endif **/
    /**- endfor **/
  ) :
    /**- if struct.inherits **/
    /*=- struct.inherits.name =*/(
      /**- for field in struct.key_fields **/
      /*=- field.name =*//** if not loop.last **/, /** endif **/
      /**- endfor **/
    )
    /**- else **/
    /**- for field in struct.key_fields **/
    /*=- field.name =*/(/*= field.name =*/)/** if not loop.last **/, /** endif **/
    /**- endfor **/
    /**- endif **/ {
      /**- if struct.inherits and not 'Kind' in struct.key_fields | map(attribute='name') -**/
      Kind = AssociatedKind;
      /**- endif -**/
    }
  /** endif **/

  /*# --- Full constructor --- #*/
  /** if struct.emit_full_constructor **/
  /// Full constructor
  /*= struct.name =*/(
    /*#- Inherited fields #*/
    /**- for field in struct.inherits.fields **/
    /*=- field.type =*/ /*= field.name =*/
    /** if (struct.fields | length > 0) or (not loop.last) **/, /** endif **/
    /**- endfor **/

    /*#- Own fields #*/
    /**- for field in struct.fields **/
    /*=- field.type =*/ /*= field.name =*//** if not loop.last **/, /** endif **/
    /**- endfor **/
  ) :
    /*#- Invoke base class constructor #*/
    /**- if struct.inherits **/
    /*= struct.inherits.name =*/(
      /**- for field in struct.inherits.fields **/
      /*= field.name =*//** if not loop.last **/, /** endif **/
      /**- endfor **/
    )
    /** if struct.fields | length > 0 **/, /** endif **/
    /** endif **/

    /*#- Initialize own fields #*/
    /**- for field in struct.fields **/
    /*=- field.name =*/(/*= field.name =*/)/** if not loop.last **/, /** endif **/
    /**- endfor **/ {}
  /** endif **/

  /*# --- Key definition for KeyedObjectTraits --- #*/
  /** if struct._key **/
  using KeyTuple = std::tuple<
    /**- for key_field in struct.key_fields -**/
    /*= key_field.type =*//** if not loop.last **/, /** endif **/
    /**- endfor -**/
  >;
  struct Key : public KeyTuple {
    using KeyTuple::KeyTuple;
  };
  /** endif **/

  /*# --- Comparison operator --- #*/
  /** if struct.key_fields **/
  Key key() const {
    return Key {
      /**- for key_field in struct.key_fields -**/
      /*= key_field.name =*//** if not loop.last **/, /** endif **/
      /**- endfor -**/
    };
  }

  std::string stringKey() const {
    return /** for key_field in struct.key_fields -**/
    /*= key_field | string_converter =*//** if not loop.last **/ + "-" + /** endif **/
    /**- endfor -**/;
  }

  bool operator==(const /*= struct.name =*/ &Other) const { return key() == Other.key(); }
  bool operator<(const /*= struct.name =*/ &Other) const { return key() < Other.key(); }
  bool operator>(const /*= struct.name =*/ &Other) const { return key() > Other.key(); }

  /** else **/
  bool operator==(const /*= struct.name =*/ &Other) const = default;
  /** endif **/

  bool localCompare(const /*= struct.user_fullname =*/ &Other) const;
};

/** if struct._key **/
template<>
struct std::tuple_size</*= struct.fullname =*/::Key>
  : public std::tuple_size</*= struct.fullname =*/::KeyTuple> {};

template<std::size_t I>
struct std::tuple_element<I, /*= struct.fullname =*/::Key>
  : public std::tuple_element<I, /*= struct.fullname =*/::KeyTuple> {};
/** endif **/

/*# --- UpcastablePointer stuff --- #*/
/** if upcastable **/
/*# Emit both const and non-const specialization of concrete_types_traits #*/
/** for const_qualifier in ["", "const"] **/
template<>
struct concrete_types_traits</*= const_qualifier =*/ /*= struct.user_fullname =*/> {
  using type = std::tuple<
    /**- for child_type in upcastable|sort(attribute="user_fullname") **/
    /*=- const_qualifier =*/ /*= child_type.user_fullname =*//** if not loop.last **/, /** endif **/
    /**- endfor **/
    /**- if not struct.abstract **/, /*=- const_qualifier =*/ /*= struct.user_fullname =*//** endif **/>;
};
/** endfor **/
/** endif **//*# End UpcastablePointer stuff #*/

