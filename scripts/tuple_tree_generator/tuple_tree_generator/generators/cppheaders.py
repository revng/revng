#
# This file is distributed under the MIT License. See LICENSE.md for details.
#

import graphlib
from collections import defaultdict
from typing import Dict, Iterable

from .generator import Generator
from .jinja_utils import environment
from ..definition import StructDefinition, EnumDefinition

enum_template = environment.get_template("enum.h.tpl")
struct_template = environment.get_template("struct.h.tpl")
struct_late_template = environment.get_template("struct_late.h.tpl")
struct_impl_template = environment.get_template("struct_impl.cpp.tpl")
struct_forward_decls_template = environment.get_template("struct_forward_decls.h.tpl")
class_forward_decls_template = environment.get_template("class_forward_decls.h.tpl")


class CppHeadersGenerator(Generator):
    def emit(self) -> Dict[str, str]:
        sources = {
            "ForwardDecls.h": emit_forward_decls(self.struct_definitions()),
        }

        early_definitions = self._emit_early_type_definitions()
        late_definitions = self._emit_late_type_definitions()
        impl_definitions = self._emit_impl()
        sources.update(early_definitions)
        sources.update(late_definitions)
        sources.update(impl_definitions)
        return sources

    def _emit_early_type_definitions(self):
        definitions = {}
        toposorter = graphlib.TopologicalSorter(self.depgraph)
        order = list(toposorter.static_order())
        for type_name_to_emit in order:
            type_to_emit = self.get_definition_for(type_name_to_emit)
            if not type_to_emit:
                # Should we emit a warning here?
                continue

            filename = f"Early/{type_to_emit.filename}"
            assert filename not in definitions
            if isinstance(type_to_emit, StructDefinition):
                definition = self._emit_early_struct(type_to_emit)
            elif isinstance(type_to_emit, EnumDefinition):
                definition = enum_template.render(enum=type_to_emit)
            else:
                raise ValueError()

            definitions[filename] = definition

        return definitions

    def _emit_early_struct(self, definition: StructDefinition):
        upcastable_types = self._get_upcastable_types(definition)
        return struct_template.render(struct=definition, upcastable=upcastable_types)

    def _emit_late_type_definitions(self):
        definitions = {}
        for type_to_emit in self._definitions.values():
            filename = f"Late/{type_to_emit.filename}"
            assert filename not in definitions

            if isinstance(type_to_emit, StructDefinition):
                definition = self._emit_late_struct(type_to_emit)
            elif isinstance(type_to_emit, EnumDefinition):
                definition = ""
            else:
                raise ValueError()

            definitions[filename] = definition
        return definitions

    def _emit_late_struct(self, definition: StructDefinition):
        upcastable_types = self._get_upcastable_types(definition)
        return struct_late_template.render(struct=definition, upcastable=upcastable_types)

    def _emit_impl(self):
        definitions = {}
        for type_to_emit in self._definitions.values():
            filename = f"Impl/{type_to_emit.impl_filename}"
            assert filename not in definitions

            if isinstance(type_to_emit, StructDefinition):
                definition = self._emit_impl_struct(type_to_emit)
            elif isinstance(type_to_emit, EnumDefinition):
                definition = ""
            else:
                raise ValueError()

            definitions[filename] = definition

        return definitions

    def _emit_impl_struct(self, definition: StructDefinition):
        upcastable_types = self._get_upcastable_types(definition)
        return struct_impl_template.render(struct=definition, upcastable=upcastable_types)


def emit_forward_decls(definitions: Iterable[StructDefinition]):
    generated_ns_to_names = defaultdict(set)
    user_ns_to_names = defaultdict(set)
    for definition in definitions:
        # Forward declaration for autogenerated class
        generated_ns_to_names[definition.namespace].add(definition.name)
        # Forward declaration for user-defined derived class
        user_ns_to_names[definition.user_namespace].add(definition.name)

    return "\n".join([
        struct_forward_decls_template.render(ns_to_names=generated_ns_to_names),
        class_forward_decls_template.render(ns_to_names=user_ns_to_names),
    ])
