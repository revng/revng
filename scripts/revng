#!/usr/bin/env python3

import argparse
import glob
import os
import re
import subprocess
import sys

from binascii import hexlify
from ctypes.util import find_library
from functools import reduce
from itertools import chain
try:
    from shutil import which
except ImportError:
    from backports.shutil_which import which

from elftools.elf.dynamic import DynamicSegment
from elftools.elf.elffile import ELFFile

from revng_translate import register_translate, run_translate
from revng_support import *

search_prefixes = []
real_argv0 = os.environ.get("REAL_ARGV0", sys.argv[0])

def interleave(base, repeat):
    return list(sum(zip([repeat] * len(base), base), ()))

# Use in case different version of pyelftools might give str or bytes

def to_string(obj):
    if type(obj) is str:
        return obj
    elif type(obj) is bytes:
        return obj.decode("utf-8")


def get_elf_needed(path):
    with open(path, "rb") as elf_file:
        segments = [segment
                    for segment
                    in ELFFile(elf_file).iter_segments()
                    if type(segment) is DynamicSegment]

        if len(segments) == 1:
            needed = [to_string(tag.needed)
                      for tag
                      in segments[0].iter_tags()
                      if tag.entry.d_tag == "DT_NEEDED"]

            runpath = [tag.runpath
                       for tag
                       in segments[0].iter_tags()
                       if tag.entry.d_tag == "DT_RUNPATH"]

            assert len(runpath) < 2

            if not runpath:
                return needed
            else:
                runpaths = [runpath.replace("$ORIGIN",
                                            os.path.dirname(path))
                            for runpath
                            in runpath[0].split(":")]
                absolute_needed = []
                for lib in needed:
                    found = False
                    for runpath in runpaths:
                        full_path = os.path.join(runpath, lib)
                        if os.path.isfile(full_path):
                            absolute_needed.append(full_path)
                            found = True
                            break

                    if not found:
                        absolute_needed.append(lib)

                return absolute_needed

        else:
            return []


def build_opt_args(args, search_path):
    all = {}
    for prefix in search_prefixes:
        analyses_path = os.path.join(prefix, "lib", "revng", "analyses")
        if not os.path.isdir(analyses_path):
            continue

        # Enumerate all the libraries containing analyses
        for library in glob.glob(os.path.join(analyses_path, "*.so")):
            basename = os.path.basename(library)
            if basename not in all:
                all[basename] = library

    # Identify all the libraries that are dependencies of other libraries, i.e.,
    # non-roots in the dependencies tree. Note that circular dependencies are
    # not allowed.
    provided = set(chain.from_iterable([get_elf_needed(path)
                                        for path
                                        in all.values()]))

    # Path to libraries representing the roots in the dependency tree
    provided_so_names = set(os.path.basename(lib) for lib in provided)
    roots = [relative(path)
             for basename, path
             in all.items()
             if basename not in provided_so_names]

    prefix = []
    libasan = [name
               for name
               in provided
               if ("libasan." in name
                   or "libclang_rt.asan" in name)]
    if len(libasan) == 1:
        libasan_path = relative(libasan[0])
        original_asan_options = os.environ.get("ASAN_OPTIONS", "")
        if original_asan_options:
            asan_options = dict([option.split("=")
                                 for option
                                 in original_asan_options.split(":")])
        else:
            asan_options = dict()
        asan_options["abort_on_error"] = "1"
        new_asan_options = ":".join(["=".join(option)
                                     for option
                                     in asan_options.items()])

        # Use `sh` instead of `env` since `env` sometimes is not a real executable
        # but a shebang script spawning /usr/bin/coreutils, which makes gdb unhappy
        prefix = [get_command("sh", search_path),
                  "-c",
                  'LD_PRELOAD={} ASAN_OPTIONS={} '
                  'exec "$0" "$@"'.format(libasan_path, new_asan_options)]

    return (prefix + [relative(get_command("opt", search_path))]
            + interleave(roots, "-load")
            + args
            + ["-serialize-model"])


def split_dash_dash(args):
    if not args:
        return [], []

    extra_args = []
    while (len(args) != 0) and (args[0] != "--"):
        extra_args.append(args[0])
        del args[0]

    # Drop the delimiter
    if len(args) != 0:
        del args[0]

    return list(extra_args), args


def find_file(name, paths):
    for path in paths:
        path = os.path.join(path, name)
        if os.path.isfile(path):
            return path

    log_error("Can't find the following file: {}".format(name))
    assert False


def get_stderr(args):
    with subprocess.Popen(args, stderr=subprocess.PIPE) as process:
        return process.stderr.read()


def run_cc(args):
    # Collect translate options
    translated_args = []
    if "--" in args:
        translate_args, args = split_dash_dash(args)

    if (not args) or ("--help" in args):
        log_error(f"Usage: {real_argv0} cc [[translate-options] --] compiler "
                  + "[compiler-options]")
        return -1

    res = subprocess.call(args)
    if res != 0:
        return res

    # Are we linking?
    if not ("-c" in args):
        assert "-o" in args

        # Identify the path of the final program
        output = os.path.abspath(args[args.index("-o") + 1])

        original = output + ".original"
        translated = original + ".translated"
        os.rename(output, original)

        result = run_translate(translate_args + [original])
        if result != 0:
            return result

        os.rename(translated, output)

    return res


def main():
    parser = argparse.ArgumentParser(description="The rev.ng driver.")
    parser.add_argument("--version",
                        action="store_true",
                        help="Display version information.")
    parser.add_argument("--verbose",
                        action="store_true",
                        help="Log all executed commands.")
    parser.add_argument("--perf",
                        action="store_true",
                        help="Run programs under perf (for use with hotspot).")
    parser.add_argument("--heaptrack",
                        action="store_true",
                        help="Run programs under heaptrack.")
    parser.add_argument("--gdb",
                        action="store_true",
                        help="Run programs under gdb.")
    parser.add_argument("--lldb",
                        action="store_true",
                        help="Run programs under lldb.")
    parser.add_argument("--valgrind",
                        action="store_true",
                        help="Run programs under valgrind.")
    parser.add_argument("--callgrind",
                        action="store_true",
                        help="Run programs under callgrind.")
    parser.add_argument("--prefix",
                        action="append",
                        metavar="PREFIX",
                        help="Additional search prefix.")

    # Get script_path
    global script_path
    script_path = os.path.dirname(os.path.realpath(__file__))

    # Create a custom PATH variable to find programs
    search_path = os.environ["PATH"]
    if search_path:
        search_path = "{}:{}".format(script_path, search_path)
    else:
        search_path = script_path

    subparsers = parser.add_subparsers(dest="command_name",
                                       help='sub-commands help')

    register_translate(subparsers)

    subparsers.add_parser("cc",
                          help="compile, link and translate transparently",
                          add_help=False)
    subparsers.add_parser("opt",
                          help="LLVM's opt with rev.ng passes",
                          add_help=False)

    programs = set()
    prefix = "revng-"
    for path in search_path.split(":"):
        if os.path.isdir(path):
            for program in os.listdir(path):
                if program.startswith(prefix) and which(program, path=search_path):
                    name = program[len(prefix):]
                    subparsers.add_parser(name,
                                          help=f"see {name} --help",
                                          add_help=False) 
    global revng_parser 
    revng_parser = parser

    # Strip away arguments -- so we can forward them to revng-lift
    base_args, post_dash_dash = split_dash_dash(sys.argv[1:])

    args, unknown_args = parser.parse_known_args(base_args)

    global search_prefixes
    search_prefixes = ((args.prefix or [])
                       + [os.path.join(script_path, "..")])

    global log_commands
    log_commands = args.verbose

    command_prefix = []

    assert (args.gdb + args.lldb + args.valgrind + args.callgrind) <= 1

    if args.gdb:
        command_prefix += ["gdb", "-q", "--args"]

    if args.lldb:
        command_prefix += ["lldb", "--"]

    if args.valgrind:
        command_prefix += ["valgrind"]

    if args.callgrind:
        command_prefix += ["valgrind", "--tool=callgrind"]

    if args.perf:
        command_prefix += ["perf",
                           "record",
                           "--call-graph", "dwarf",
                           "--output=perf.data"]

    if args.heaptrack:
        command_prefix += ["heaptrack"]

    if args.version:
        sys.stdout.write("rev.ng version @VERSION@\n")
        return 0

    return run_command(args, unknown_args, post_dash_dash, search_path, command_prefix)


def run_command(args, unknown_args, post_dash_dash, search_path, command_prefix):
    command = args.command_name
    if not command:
        log_error("No command specified")
        return 1

    all_args = list(unknown_args)
    if post_dash_dash:
        all_args += ["--"] + post_dash_dash

    # First consider the hardcoded commands
    if command == "opt":
        run(build_opt_args(all_args, search_path), command_prefix)
    elif command == "cc":
        return run_cc(all_args)
    elif command == "translate":
        assert not unknown_args
        return run_translate(args, search_path, command_prefix)
    else:
        executable = "revng-" + command
        if not which(executable, path=search_path):
            log_error("Can't find the following command: {}".format(executable))
            return 1
        in_path = get_command(executable, search_path)
        if in_path:
            arguments = [os.path.abspath(in_path)] + all_args
            run(arguments, command_prefix)
        else:
            log_error("\"revng-{}\" is not a valid command".format(command))
            return 1


if __name__ == "__main__":
    sys.exit(main())
