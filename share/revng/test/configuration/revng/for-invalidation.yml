#
# This file is distributed under the MIT License. See LICENSE.md for details.
#

commands:
  - type: revng.test-invalidation
    from:
      - type: revng-qa.compiled-with-debug-info
        filter: for-invalidation
    command: |-
      ./test-invalidation.sh "$INPUT" "$SOURCE"
    scripts:
      test-invalidation.sh: |-
        #!/usr/bin/env bash

        BASELINE_LLVM_BITCODE="$$(temp)";
        BASELINE_MODEL="$$(temp)";
        BASELINE_MODEL_NAMED_DYN_FUNC="$$(temp)";
        BASELINE_MODEL_OVERRIDEN="$$(temp)";
        CFG="$$(temp)";
        DIFF="$$(temp)";
        TMP_FOLDER="$$(temp -d)";
        INITIAL_PIPELINE_RESUME="$$(temp -d)";

        # Lift the input binary and run DetectABI
        revng analyze --resume "$$INITIAL_PIPELINE_RESUME" AddPrimitiveTypes "$1" -o /dev/null;
        revng analyze --resume "$$INITIAL_PIPELINE_RESUME" ImportBinary "$1" -o /dev/null;
        revng analyze --resume "$$INITIAL_PIPELINE_RESUME" DetectABI "$1" -o "$$BASELINE_MODEL";
        revng artifact --resume "$$INITIAL_PIPELINE_RESUME" EnforceABI "$1" \
          | revng model inject "$$BASELINE_MODEL" > "$$BASELINE_LLVM_BITCODE";

        # Extract the CFG
        revng efa-extractcfg < "$$BASELINE_LLVM_BITCODE" > "$$CFG";

        # Add `plt_` as a prefix to stubs calling dynamic functions
        ./customname-and-inline-to-dynamicfunctions.py "$$CFG" "$$BASELINE_MODEL" > "$$BASELINE_MODEL_NAMED_DYN_FUNC";

        # Override by name the given one with the just obtained model
        cat "$$BASELINE_MODEL_NAMED_DYN_FUNC" > lamo;
        revng model override-by-name --remove-others "$$BASELINE_MODEL_NAMED_DYN_FUNC" "$2".override.yml > "$$BASELINE_MODEL_OVERRIDEN";

        # Produce various containers preparatory to the invalidation
        revng pipeline \
          -i "$1":begin/input \
          -m "$$BASELINE_MODEL_OVERRIDEN" \
          --analyze Lift/DetectABI/module.ll/:Root \
          --resume "$$TMP_FOLDER" \
          --produce Isolate/module.ll/*:Isolated;

        # Test ground truth
        for FILE in "$2".overrides/*.yml; do
          # Override by name the obtained module with each file change.
          # Remove possible functions from the model (the name of the function to be removed needs to start with "-").
          # Create the diff.
          revng model override-by-name "$$BASELINE_MODEL_OVERRIDEN" "$FILE" \
            | ./remove-candidate-functions-from-model.py /dev/stdin "$FILE" \
            | (revng model diff "$$BASELINE_MODEL_OVERRIDEN" /dev/stdin || true) > "$$DIFF";

          # Calculate the targets to be invalidated
          revng print-invalidations --resume "$$TMP_FOLDER" "$$DIFF" \
            | ./metaaddress-to-customname.py "$$BASELINE_MODEL_OVERRIDEN" /dev/stdin \
            | diff -B /dev/stdin <(grep -vE '^\s*#' "$FILE".invalidations);
        done

      customname-and-inline-to-dynamicfunctions.py: |-
        #!/usr/bin/env python3

        import sys
        import yaml
        from revng import model

        with open(sys.argv[1]) as input_cfg:
          cfg = yaml.safe_load(input_cfg)

        with open(sys.argv[2]) as input_model_file:
          baseline_model = yaml.load(input_model_file, Loader=model.YamlLoader)

        for line in cfg:
          for entry in line['FunctionMetadata']['ControlFlowGraph']:
            for successor in entry['Successors']:
              if 'DynamicFunction' in successor:
                function = next(f for f in baseline_model.Functions if repr(f.Entry) == line['Entry'])
                function.OriginalName = "plt_" + successor['DynamicFunction']
                function.CustomName = "plt_" + successor['DynamicFunction']

        print(yaml.dump(baseline_model, Dumper=model.YamlDumper))

      remove-candidate-functions-from-model.py: |-
        #!/usr/bin/env python3

        import sys
        import yaml
        from revng import model

        with open(sys.argv[1]) as input_model_file:
          baseline_model = yaml.load(input_model_file, Loader=model.YamlLoader)

        with open(sys.argv[2]) as input_override_file:
          override_model = yaml.load(input_override_file, Loader=yaml.SafeLoader)

        for function_to_override in override_model["Functions"]:
          if function_to_override["CustomName"].startswith('-'):
            function_name = function_to_override["OriginalName"]
            baseline_model.Functions = [d for d in baseline_model.Functions if d.OriginalName != function_name]

        print(yaml.dump(baseline_model, Dumper=model.YamlDumper))

      metaaddress-to-customname.py: |-
        #!/usr/bin/env python3

        import sys
        import yaml
        from revng import model

        with open(sys.argv[1]) as input_model_file:
          baseline_model = yaml.load(input_model_file, Loader=model.YamlLoader)

        with open(sys.argv[2]) as input_invalidations_file:
          for line in input_invalidations_file:
            metaaddress = ':'.join(line[1:].split(':')[:-1])
            for function in baseline_model.Functions:
              if function.Entry == model.MetaAddress.from_string(metaaddress):
                print(function.CustomName)
